
---

# گزارش پروژه بافر اورفلو (Buffer Overflow) و اجرای Payload

## مقدمه

در این پروژه، هدف بررسی آسیب‌پذیری بافر اورفلو در برنامه‌ای ساده و بهره‌برداری از آن برای اجرای تابع مخفی (`secret`) بود. این آسیب‌پذیری به دلیل عدم بررسی اندازه ورودی در تابع `gets()` رخ می‌دهد که امکان بازنویسی رجیسترهای مهم مانند RIP را فراهم می‌کند.

---

## شرح برنامه

برنامه اصلی دارای دو تابع است:

* `vulnerable()`: تابعی که یک آرایه `buffer` به طول 10 بایت دارد و ورودی کاربر را با استفاده از `gets()` دریافت می‌کند.
* `secret()`: تابع مخفی که با فراخوانی آن پیام دسترسی موفقیت‌آمیز چاپ می‌شود و برنامه خارج می‌شود.

مشکل اصلی در استفاده از `gets()` است که کنترل اندازه ورودی را انجام نمی‌دهد و باعث ایجاد بافر اورفلو می‌شود.

---

## مراحل انجام پروژه

### 1. شناسایی اندازه بافر

با وارد کردن رشته‌های مختلف از کاراکتر `A` و بررسی محل کرش (crash) در دیباگر (`gdb`)، مشخص شد با وارد کردن بیش از 10 کاراکتر، مقدار رجیسترهای مهم مانند `rbp` و `rip` تغییر می‌کند.

### 2. ساخت الگوی (Pattern) برای یافتن Offset

برای پیدا کردن دقیق تعداد بایت‌هایی که باعث بازنویسی RIP می‌شوند، از ابزار `msf-pattern_create` استفاده شد.
دستور ایجاد الگو:

```bash
msf-pattern_create -l 100
```

سپس با بررسی مقدار `rbp` یا مقدار کرش شده در RIP، مقدار offset محاسبه شد:

```bash
msf-pattern_offset <crash_value>
```

مثال:

```bash
msf-pattern_offset 3561413461413361
```

که خروجی نشان داد offset برابر با 10 است.

### 3. ساخت Payload با زبان C

برای تولید یک فایل باینری payload که شامل:

* تعداد مشخصی از کاراکترها تا رسیدن به offset (مثلاً 10 کاراکتر)
* جایگزینی RIP با آدرس تابع `secret()`
  کد C نوشته و اجرا شد تا فایل `payload.bin` ساخته شود.

### 4. اجرای Payload

برای اجرای برنامه آسیب‌پذیر با ورودی فایل payload، دستور زیر در ترمینال اجرا شد:

```bash
./main < payload.bin
```

یا در داخل gdb:

```bash
gdb ./main
(gdb) run < payload.bin
```

نتیجه اجرای موفق برنامه، فراخوانی تابع `secret()` و نمایش پیام:

```
Access Granted! You've hacked the sesytem.
```

---

## نتیجه‌گیری

* آسیب‌پذیری بافر اورفلو به دلیل استفاده ناامن از `gets()` باعث امکان اجرای کد دلخواه یا تغییر مسیر اجرای برنامه شد.
* با استفاده از ابزارهای الگو (pattern) و offset می‌توان محل دقیق بازنویسی RIP را شناسایی کرد.
* payload تولید شده موفق به فراخوانی تابع مخفی `secret()` شد و هدف پروژه محقق گردید.

---

## پیشنهادات

* استفاده از توابع امن‌تر مانند `fgets()` به جای `gets()`.
* افزودن کنترل دقیق اندازه ورودی در برنامه‌ها.
* آشنایی با ابزارهای متااسپلویت و gdb برای شناسایی و بهره‌برداری از آسیب‌پذیری‌ها.

---

